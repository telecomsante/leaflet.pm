{"version":3,"sources":["leaflet.pm.js","Drag.js","Overlap.js","Snapping.js","L.PM.js","L.PM.Map.js","L.PM.Draw.js","L.PM.Edit.js","Draw/L.PM.Draw.Line.js","Draw/L.PM.Draw.Poly.js","Edit/L.PM.Edit.LayerGroup.js","Edit/L.PM.Edit.Line.js","Edit/L.PM.Edit.Poly.js","Toolbar/L.Controls.js","Toolbar/L.PM.Toolbar.js"],"names":["DragMixin","_initDraggableLayer","_this","this","_tempDragCoord","PMObj","_poly","_line","el","_path","L","DomUtil","addClass","onMouseUp","e","_map","dragging","enable","off","_initMarkers","window","setTimeout","_dragging","removeClass","fire","_fireEdit","onMouseMove","bringToFront","disable","_markerGroup","clearLayers","_onLayerDrag","on","latlng","deltaLatLng","lat","lng","coords","_latlngs","newLatLngs","map","currentLatLng","setLatLngs","redraw","OverlapMixin","_applyPossibleCoordsChanges","_tempPolygon","latlngs","getLayers","getLatLngs","_drawTemporaryPolygon","geoJson","setStyle","opacity","fillOpacity","addTo","bringToBack","_handleOverlap","mainPoly","layers","_layerGroup","changed","resultingGeoJson","toGeoJSON","filter","layer","Object","is","intersect","turf","console","warn","difference","geometry","type","remove","SnapMixin","_initSnappableMarkers","options","snapDistance","_markers","forEach","marker","_handleSnapping","_cleanupSnapping","_unsnap","_snapLatLng","_snapList","debugIndicatorLines","line","undefined","_createSnapList","length","target","closestLayer","_calcClosestLayer","getLatLng","snapLatLng","_checkPrioritiySnapping","minDistance","eventInfo","segment","layerInteractedWith","distance","setLatLng","_onMarkerDrag","A","B","C","distanceAC","_getDistance","distanceBC","closestVertexLatLng","shortestDistance","priorityDistance","snapLatlng","eachLayer","Polyline","push","debugLine","polyline","color","_this2","index","results","_calcLayerDistances","_this3","P","closestSegment","coord","nextIndex","_getDistanceToSegment","_getClosestPointOnSegment","latlngA","latlngB","maxzoom","getMaxZoom","Infinity","getZoom","project","closest","LineUtil","closestPointOnSegment","unproject","latLngToLayerPoint","pointToSegmentDistance","distanceTo","PM","initialize","initLayerGroup","pm","Edit","LayerGroup","addInitHook","initPolygon","Poly","Polygon","initLine","Line","initMap","Map","Class","extend","Draw","Toolbar","addControls","enableDraw","shape","arguments","disableDraw","removeLayer","_layers","toggleRemoval","enabled","globalEditEnabled","_globalEditMode","toggleGlobalEditMode","shapes","getShapes","join","addButton","includes","_shape","registerButton","toolbarButtonName","_enabled","_polyline","addLayer","_hintline","dashArray","_container","style","cursor","_createLinePoint","_syncHintLine","toggleButton","toggle","linePoints","lastLinePoint","last","addLatLng","_createMarker","Marker","draggable","icon","divIcon","className","_finishLine","lineLayer","_createPolygonPoint","polyPoints","lastPolygonPoint","first","_finishPolygon","polygonLayer","polygon","layerGroup","availableEvents","event","_fireEvent","getOptions","fireEvent","toggleEdit","_options","find","k","_createMiddleMarker","snappable","_origLatLng","_index","_onMarkerDragEnd","_removeMarker","leftM","rightM","_calcMiddleLatLng","middleMarker","setIcon","_middleMarkerNext","_middleMarkerPrev","_addMarker","newM","splice","i","leftMarkerIndex","rightMarkerIndex","nextMarkerIndex","prevMarkerIndex","_latlng","markerLatLng","prevMarkerLatLng","nextMarkerLatLng","middleMarkerNextLatLng","middleMarkerPrevLatLng","edited","latlng1","latlng2","p1","p2","_add","_divideBy","poly","Control","PMButton","position","_button","setButton","onAdd","container","buttonsDomNode","_makeButton","appendChild","onRemove","button","iconUrl","onClick","afterClick","doToggle","toggleStatus","disableOtherButtons","getText","text","getIconUrl","destroy","_update","_applyStyleClasses","toggled","onCreate","_triggerClick","_clicked","newButton","create","image","setAttribute","DomEvent","addListener","triggerClickOnToggledButtons","disableClickPropagation","drawLine","drawPolygon","editPolygon","dragPolygon","deleteLayer","buttons","_defineButtons","getButtons","Util","setOptions","_showHideButtons","_addButton","name","exceptThisButton","status","deleteButton","drawLineButton","drawPolyButton","editButton","dragButton","btn"],"mappings":"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","file":"leaflet.pm.min.js","sourcesContent":["'use strict';\n\nvar DragMixin = {\n    _initDraggableLayer: function _initDraggableLayer() {\n        var _this = this;\n\n        // temporary coord variable for delta calculation\n        this._tempDragCoord;\n\n        var PMObj = this._poly || this._line;\n\n        // add CSS class\n        var el = PMObj._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n        var onMouseUp = function onMouseUp(e) {\n\n            // re-enable map drag\n            PMObj._map.dragging.enable();\n\n            // clear up mousemove event\n            PMObj._map.off('mousemove');\n\n            // clear up mouseup event\n            PMObj.off('mouseup');\n\n            // show markers again\n            _this._initMarkers();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(function () {\n                // set state\n                _this._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n                // fire pm:dragend event\n                PMObj.fire('pm:dragend');\n\n                // fire edit\n                _this._fireEdit();\n            }, 10);\n        };\n\n        var onMouseMove = function onMouseMove(e) {\n\n            if (!_this._dragging) {\n\n                // set state\n                _this._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                PMObj.bringToFront();\n\n                // disbale map drag\n                PMObj._map.dragging.disable();\n\n                // hide markers\n                _this._markerGroup.clearLayers();\n\n                // fire pm:dragstart event\n                PMObj.fire('pm:dragstart');\n            }\n\n            _this._onLayerDrag(e);\n        };\n\n        PMObj.on('mousedown', function (e) {\n\n            // save for delta calculation\n            _this._tempDragCoord = e.latlng;\n\n            PMObj.on('mouseup', onMouseUp);\n\n            // listen to mousemove on map (instead of polygon),\n            // otherwise fast mouse movements stop the drag\n            PMObj._map.on('mousemove', onMouseMove);\n        });\n    },\n    dragging: function dragging() {\n        return this._dragging;\n    },\n\n    _onLayerDrag: function _onLayerDrag(e) {\n        var PMObj = this._poly || this._line;\n        // latLng of mouse event\n        var latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        var deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng\n        };\n\n        // create the new coordinates array\n        var coords = PMObj._latlngs[0];\n        var newLatLngs = coords.map(function (currentLatLng) {\n            return {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            };\n        });\n\n        // set new coordinates and redraw\n        PMObj.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // fire pm:dragstart event\n        PMObj.fire('pm:drag');\n    }\n};\n'use strict';\n\n// this isn't included anymore but if you want to re-enable it:\n// 1. include this mixing inside L.PM.Edit.js\n// 2. include the turf.js dependency in your project before leaflet.pm\n// 3. uncomment all code inside L.PM.Edit.Poly that has an if-check on options.preventOverlap\n// 4. pass the option preventOverlap to the enable() function on your layer\nvar OverlapMixin = {\n\n    _applyPossibleCoordsChanges: function _applyPossibleCoordsChanges() {\n\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if (this._tempPolygon) {\n\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n    },\n\n    _drawTemporaryPolygon: function _drawTemporaryPolygon(geoJson) {\n\n        // hide our polygon\n        this._poly.setStyle({ opacity: 0, fillOpacity: 0 });\n\n        // draw a temporary polygon (happens during drag & intersection)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n    },\n\n    _handleOverlap: function _handleOverlap() {\n\n        var mainPoly = this._poly;\n        var layers = this._layerGroup.getLayers();\n        var changed = false;\n        var resultingGeoJson = this._poly.toGeoJSON();\n\n        layers.filter(function (layer) {\n            return !Object.is(layer, mainPoly);\n        }).map(function (layer) {\n\n            var intersect = void 0;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch (e) {\n                console.warn('Turf Error.');\n            }\n\n            if (intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if (resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n        });\n\n        if (this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if (changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({ opacity: 1, fillOpacity: 0.2 });\n        }\n    }\n};\n'use strict';\n\nvar SnapMixin = {\n    _initSnappableMarkers: function _initSnappableMarkers() {\n        var _this = this;\n\n        var PMObj = this._poly || this._line;\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        this._markers.forEach(function (marker) {\n\n            marker.off('drag', _this._handleSnapping, _this);\n            marker.on('drag', _this._handleSnapping, _this);\n\n            marker.off('dragend', _this._cleanupSnapping, _this);\n            marker.on('dragend', _this._cleanupSnapping, _this);\n        });\n\n        PMObj.off('pm:dragstart', this._unsnap, this);\n        PMObj.on('pm:dragstart', this._unsnap, this);\n    },\n    _unsnap: function _unsnap(e) {\n        // delete the last snap\n        delete this._snapLatLng;\n    },\n    _cleanupSnapping: function _cleanupSnapping(e) {\n\n        // delete it, we need to refresh this with each start of a drag because\n        // meanwhile, new layers could've been added to the map\n        delete this._snapList;\n\n        this.debugIndicatorLines.forEach(function (line) {\n            line.remove();\n        });\n    },\n    _handleSnapping: function _handleSnapping(e) {\n        var PMObj = this._poly || this._line;\n\n        // create a list of polygons that the marker could snap to\n        // this isn't inside a movestart/dragstart callback because middlemarkers are initialized\n        // after dragstart/movestart so it wouldn't fire for them\n        if (this._snapList === undefined) {\n            this._createSnapList(e);\n        }\n\n        // if there are no layers to snap to, stop here\n        if (this._snapList.length <= 0) {\n            return false;\n        }\n\n        var marker = e.target;\n\n        // get the closest layer, it's closest latlng, segment and the distance\n        var closestLayer = this._calcClosestLayer(marker.getLatLng(), this._snapList);\n\n        // find the final latlng that we want to snap to\n        var snapLatLng = this._checkPrioritiySnapping(closestLayer);\n\n        // minimal distance before marker snaps (in pixels)\n        var minDistance = this.options.snapDistance;\n\n        // event info for pm:snap and pm:unsnap\n        var eventInfo = {\n            marker: marker,\n            snapLatLng: snapLatLng,\n            segment: closestLayer.segment,\n            layer: PMObj,\n            layerInteractedWith: closestLayer.layer // for lack of a better property name\n        };\n\n        if (closestLayer.distance < minDistance) {\n\n            // snap the marker\n            marker.setLatLng(snapLatLng);\n            this._onMarkerDrag(e);\n\n            // check if the snapping position differs from the last snap\n            if (this._snapLatLng !== snapLatLng) {\n\n                // if yes, save it and fire the pm:snap event\n                this._snapLatLng = snapLatLng;\n                marker.fire('pm:snap', eventInfo);\n                PMObj.fire('pm:snap', eventInfo);\n            }\n        } else {\n            // no more snapping\n\n            // if it was previously snapped...\n            if (this._snapLatLng) {\n\n                // ...unsnap\n                this._unsnap(eventInfo);\n\n                // and fire unsnap event\n                eventInfo.marker.fire('pm:unsnap', eventInfo);\n                PMObj.fire('pm:unsnap', eventInfo);\n            }\n        }\n    },\n\n    // we got the point we want to snap to (C), but we need to check if a coord of the polygon\n    // receives priority over C as the snapping point. Let's check this here\n    _checkPrioritiySnapping: function _checkPrioritiySnapping(closestLayer) {\n        var PMObj = this._poly || this._line;\n        var map = PMObj._map;\n\n        // A and B are the points of the closest segment to P (the marker position we want to snap)\n        var A = closestLayer.segment[0];\n        var B = closestLayer.segment[1];\n\n        // C is the point we would snap to on the segment.\n        // The closest point on the closest segment of the closest polygon to P. That's right.\n        var C = closestLayer.latlng;\n\n        // distances from A to C and B to C to check which one is closer to C\n        var distanceAC = this._getDistance(map, A, C);\n        var distanceBC = this._getDistance(map, B, C);\n\n        // closest latlng of A and B to C\n        var closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n        // distance between closestVertexLatLng and C\n        var shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n        // the distance that needs to be undercut to trigger priority\n        var priorityDistance = this.options.snapDistance;\n\n        // the latlng we ultemately want to snap to\n        var snapLatlng = void 0;\n\n        // if C is closer to the closestVertexLatLng (A or B) than the snapDistance,\n        // the closestVertexLatLng has priority over C as the snapping point.\n        if (shortestDistance < priorityDistance) {\n            snapLatlng = closestVertexLatLng;\n        } else {\n            snapLatlng = closestLayer.latlng;\n        }\n\n        // return the snapping point\n        return snapLatlng;\n    },\n    _createSnapList: function _createSnapList() {\n        var PMObj = this._poly || this._line;\n        var layers = [];\n        var debugIndicatorLines = [];\n\n        // find all layers that are or inherit from Polylines...\n        PMObj._map.eachLayer(function (layer) {\n            if (layer instanceof L.Polyline) {\n                layers.push(layer);\n\n                // this is for debugging\n                var debugLine = L.polyline([], { color: 'red' });\n                debugIndicatorLines.push(debugLine);\n\n                // uncomment 👇 this in to show debugging lines\n                // debugLine.addTo(this._poly._map);\n            }\n        });\n\n        // ...except myself\n        layers = layers.filter(function (layer) {\n            return PMObj !== layer;\n        });\n\n        this._snapList = layers;\n        this.debugIndicatorLines = debugIndicatorLines;\n    },\n    _calcClosestLayer: function _calcClosestLayer(latlng, layers) {\n        var _this2 = this;\n\n        var PMObj = this._poly || this._line;\n        var map = PMObj._map;\n\n        // the closest polygon to our dragged marker latlng\n        var closestLayer = {};\n\n        // loop through the layers\n        layers.forEach(function (layer, index) {\n\n            // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n            var results = _this2._calcLayerDistances(latlng, layer);\n\n            // show indicator lines, it's for debugging\n            _this2.debugIndicatorLines[index].setLatLngs([latlng, results.latlng]);\n\n            // save the info if it doesn't exist or if the distance is smaller than the previous one\n            if (closestLayer.distance === undefined || results.distance < closestLayer.distance) {\n                closestLayer = results;\n                closestLayer.layer = layer;\n            }\n        });\n\n        // return the closest layer and it's data\n        // if there is no closest layer, return undefined\n        return closestLayer;\n    },\n    _calcLayerDistances: function _calcLayerDistances(latlng, layer) {\n        var _this3 = this;\n\n        var PMObj = this._poly || this._line;\n        var map = PMObj._map;\n\n        // the point P which we want to snap (probpably the marker that is dragged)\n        var P = latlng;\n\n        // the coords of the layer\n        var coords = this._poly ? layer.getLatLngs()[0] : layer.getLatLngs();\n\n        // the closest segment (line between two points) of the layer\n        var closestSegment = void 0;\n\n        // the shortest distance from P to closestSegment\n        var shortestDistance = void 0;\n\n        // loop through the coords of the layer\n        coords.forEach(function (coord, index) {\n            // take this coord (A)...\n            var A = coord;\n\n            // and the next coord (B) as points\n            var nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            var B = coords[nextIndex];\n\n            // calc the distance between P and AB-segment\n            var distance = _this3._getDistanceToSegment(map, P, A, B);\n\n            // is the distance shorter than the previous one? Save it and the segment\n            if (shortestDistance === undefined || distance < shortestDistance) {\n                shortestDistance = distance;\n                closestSegment = [A, B];\n            }\n        });\n\n        // now, take the closest segment (closestSegment) and calc the closest point to P on it.\n        var C = this._getClosestPointOnSegment(map, latlng, closestSegment[0], closestSegment[1]);\n\n        // return the latlng of that sucker\n        return {\n            latlng: C,\n            segment: closestSegment,\n            distance: shortestDistance\n        };\n    },\n    _getClosestPointOnSegment: function _getClosestPointOnSegment(map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity) {\n            maxzoom = map.getZoom();\n        }\n        var P = map.project(latlng, maxzoom);\n        var A = map.project(latlngA, maxzoom);\n        var B = map.project(latlngB, maxzoom);\n        var closest = L.LineUtil.closestPointOnSegment(P, A, B);\n        return map.unproject(closest, maxzoom);\n    },\n    _getDistanceToSegment: function _getDistanceToSegment(map, latlng, latlngA, latlngB) {\n        var P = map.latLngToLayerPoint(latlng);\n        var A = map.latLngToLayerPoint(latlngA);\n        var B = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(P, A, B);\n    },\n    _getDistance: function _getDistance(map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    }\n};\n\"use strict\";\n\n/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize: function initialize() {\n\n        var initLayerGroup = function initLayerGroup() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        };\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n        var initPolygon = function initPolygon() {\n            this.pm = new L.PM.Edit.Poly(this);\n        };\n        L.Polygon.addInitHook(initPolygon);\n\n        var initLine = function initLine() {\n            this.pm = new L.PM.Edit.Line(this);\n        };\n        L.Polyline.addInitHook(initLine);\n\n        var initMap = function initMap() {\n            this.pm = new L.PM.Map(this);\n        };\n        L.Map.addInitHook(initMap);\n    }\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n'use strict';\n\nL.PM.Map = L.Class.extend({\n    initialize: function initialize(map) {\n        this.map = map;\n        this.Draw = new L.PM.Draw(map);\n        this.Toolbar = new L.PM.Toolbar(map);\n    },\n\n    addControls: function addControls(options) {\n        this.Toolbar.addControls(options);\n    },\n    enableDraw: function enableDraw() {\n        var shape = arguments.length <= 0 || arguments[0] === undefined ? 'Poly' : arguments[0];\n\n        this.Draw.enable(shape);\n    },\n    disableDraw: function disableDraw() {\n        var shape = arguments.length <= 0 || arguments[0] === undefined ? 'Poly' : arguments[0];\n\n        this.Draw.disable(shape);\n    },\n    removeLayer: function removeLayer(e) {\n\n        var layer = e.target;\n        if (!layer._layers && !layer.pm.dragging()) {\n            e.target.remove();\n        }\n    },\n    toggleRemoval: function toggleRemoval(enabled) {\n        var _this = this;\n\n        if (enabled) {\n            this.map.eachLayer(function (layer) {\n                layer.on('click', _this.removeLayer);\n            });\n        } else {\n            this.map.eachLayer(function (layer) {\n                layer.off('click', _this.removeLayer);\n            });\n        }\n    },\n    globalEditEnabled: function globalEditEnabled() {\n        return this._globalEditMode;\n    },\n    toggleGlobalEditMode: function toggleGlobalEditMode(options) {\n\n        // find all layers that are or inherit from Polylines...\n        var layers = [];\n        this.map.eachLayer(function (layer) {\n            if (layer instanceof L.Polyline) {\n                layers.push(layer);\n            }\n        });\n\n        if (this.globalEditEnabled()) {\n            // disable\n\n            this._globalEditMode = false;\n\n            layers.forEach(function (layer, index) {\n                layer.pm.disable();\n            });\n        } else {\n            // enable\n\n            this._globalEditMode = true;\n\n            layers.forEach(function (layer, index) {\n                layer.pm.enable(options);\n            });\n        }\n    }\n});\n'use strict';\n\nL.PM.Draw = L.Class.extend({\n\n    initialize: function initialize(map) {\n        var _this = this;\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly', 'Line'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach(function (shape) {\n            _this[shape] = new L.PM.Draw[shape](_this._map);\n        });\n    },\n    getShapes: function getShapes() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enable: function enable(shape) {\n\n        if (!shape) {\n            throw 'Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(',');\n        }\n\n        // disable drawing for all shapes\n        this.disable();\n\n        // enable draw for a shape\n        this[shape].enable();\n    },\n    disable: function disable() {\n        var _this2 = this;\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach(function (shape) {\n            _this2[shape].disable();\n        });\n    },\n    addControls: function addControls() {\n        var _this3 = this;\n\n        // add control buttons for our shapes\n        this.shapes.forEach(function (shape) {\n            _this3[shape].addButton();\n        });\n    }\n});\n\"use strict\";\n\nL.PM.Edit = L.Class.extend({\n    includes: [DragMixin, SnapMixin]\n});\n'use strict';\n\nL.PM.Draw.Line = L.PM.Draw.extend({\n\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Line';\n        this.registerButton();\n        this.toolbarButtonName = 'drawLine';\n    },\n    enable: function enable(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], { color: 'red' });\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createLinePoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n    },\n    disable: function disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createLinePoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    registerButton: function registerButton(map) {\n        var drawLineButton = {\n            'className': 'icon-line',\n            'onClick': function onClick() {},\n            'afterClick': function afterClick(e) {\n                self.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false\n        };\n    },\n    _syncHintLine: function _syncHintLine(e) {\n\n        var linePoints = this._polyline.getLatLngs();\n\n        if (linePoints.length > 0) {\n            var lastLinePoint = linePoints[linePoints.length - 1];\n            this._hintline.setLatLngs([lastLinePoint, e.latlng]);\n        }\n    },\n    _createLinePoint: function _createLinePoint(e) {\n\n        // is this the first point?\n        var last = this._polyline.getLatLngs().length === 0 ? false : true;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, last);\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n    },\n    _createMarker: function _createMarker(latlng, last) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if (last) {\n            marker.on('click', this._finishLine, this);\n        }\n\n        return marker;\n    },\n    _finishLine: function _finishLine() {\n\n        var coords = this._polyline.getLatLngs();\n        var lineLayer = L.polyline(coords).addTo(this._map);\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: lineLayer\n        });\n    }\n});\n'use strict';\n\nL.PM.Draw.Poly = L.PM.Draw.extend({\n\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Poly';\n        this.registerButton();\n        this.toolbarButtonName = 'drawPolygon';\n    },\n    enable: function enable(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], { color: 'red' });\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n    },\n    disable: function disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    registerButton: function registerButton(map) {\n\n        var drawPolyButton = {\n            'className': 'icon-polygon',\n            'onClick': function onClick() {},\n            'afterClick': function afterClick(e) {\n                self.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false\n        };\n\n        // this._drawButton = L.PM.Toolbar.addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        //\n        // this._map.on('pm:drawstart', (e) => {\n        //     if(e.shape === this._shape && !this._drawButton.toggled()) {\n        //         this._drawButton._clicked();\n        //     }\n        // });\n        //\n        // this._map.on('pm:drawend', (e) => {\n        //     if(e.shape === this._shape && this._drawButton.toggled()) {\n        //         this._drawButton._clicked();\n        //     }\n        // });\n\n    },\n    _syncHintLine: function _syncHintLine(e) {\n\n        var polyPoints = this._polyline.getLatLngs();\n\n        if (polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n    },\n    _createPolygonPoint: function _createPolygonPoint(e) {\n\n        // is this the first point?\n        var first = this._polyline.getLatLngs().length === 0 ? true : false;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n    },\n    _finishPolygon: function _finishPolygon() {\n\n        var coords = this._polyline.getLatLngs();\n        var polygonLayer = L.polygon(coords).addTo(this._map);\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n    },\n    _createMarker: function _createMarker(latlng, first) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if (first) {\n            marker.on('click', this._finishPolygon, this);\n        }\n\n        return marker;\n    }\n});\n'use strict';\n\n// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function initialize(layerGroup) {\n        var _this = this;\n\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        var availableEvents = ['pm:edit', 'pm:dragstart', 'pm:drag', 'pm:dragend', 'pm:snap', 'pm:unsnap', 'pm:raiseMarkers'];\n\n        this._layers.forEach(function (layer) {\n\n            // listen to the events of the layers in this group\n            availableEvents.forEach(function (event) {\n                layer.on(event, _this._fireEvent, _this);\n            });\n\n            // add reference for the group to each layer inside said group\n            layer.pm._layerGroup = _this._layerGroup;\n        });\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', function (e) {\n\n            _this.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if (e.target.pm.enabled()) {\n                _this.enable(_this.getOptions());\n            }\n        });\n    },\n    _fireEvent: function _fireEvent(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit: function toggleEdit(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable: function enable(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.enable(options);\n        });\n    },\n    disable: function disable() {\n        this._layers.forEach(function (layer) {\n            layer.pm.disable();\n        });\n    },\n    enabled: function enabled() {\n        var enabled = this._layers.find(function (layer) {\n            return layer.pm.enabled();\n        });\n        return !!enabled;\n    },\n    dragging: function dragging() {\n        var dragging = this._layers.find(function (layer) {\n            return layer.pm.dragging();\n        });\n        return !!dragging;\n    },\n    getOptions: function getOptions() {\n        return this._options;\n    }\n});\n'use strict';\n\nL.PM.Edit.Line = L.PM.Edit.extend({\n  initialize: function initialize(line) {\n    this._line = line;\n    this._enabled = false;\n  },\n\n  toggleEdit: function toggleEdit(options) {\n    if (!this.enabled()) {\n      this.enable(options);\n    } else {\n      this.disable();\n    }\n  },\n\n  enable: function enable() {\n    var _this = this;\n\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    this.options = options;\n\n    if (!this.enabled()) {\n      // if it was already enabled, disable first\n      // we don't block enabling again because new options might be passed\n      this.disable();\n    }\n\n    this._enabled = true;\n\n    // init markers\n    this._initMarkers();\n\n    // if polygon gets removed from map, disable edit mode\n    this._line.on('remove', function (e) {\n      _this.disable(e.target);\n    });\n\n    if (this.options.draggable) {\n      this._initDraggableLayer();\n    }\n  },\n\n  enabled: function enabled() {\n    return this._enabled;\n  },\n\n  disable: function disable() {\n    var line = arguments.length <= 0 || arguments[0] === undefined ? this._line : arguments[0];\n\n    if (!this.enabled()) {\n      return false;\n    }\n\n    // prevent disabling if polygon is being dragged\n    if (line.pm._dragging) {\n      return false;\n    }\n    line.pm._enabled = false;\n    line.pm._markerGroup.clearLayers();\n\n    // clean up draggable\n    line.off('mousedown');\n    line.off('mouseup');\n\n    // remove draggable class\n    var el = line._path;\n    L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n  },\n\n  _initMarkers: function _initMarkers() {\n    var map = this._line._map;\n\n    // cleanup old ones first\n    if (this._markerGroup) {\n      this._markerGroup.clearLayers();\n    }\n\n    // add markerGroup to map, markerGroup includes regular and middle markers\n    this._markerGroup = new L.LayerGroup();\n    map.addLayer(this._markerGroup);\n\n    // create marker for each coordinate\n    var coords = this._line._latlngs;\n\n    // the marker array, it includes only the markers that're associated with the coordinates\n    this._markers = coords.map(this._createMarker, this);\n\n    // create small markers in the middle of the regular markers\n    for (var k = 0; k < coords.length - 1; k++) {\n\n      var nextIndex = k + 1;\n      this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n    }\n\n    if (this.options.snappable) {\n      this._initSnappableMarkers();\n    }\n  },\n\n  _createMarker: function _createMarker(latlng, index) {\n    var marker = new L.Marker(latlng, {\n      draggable: true,\n      icon: L.divIcon({ className: 'marker-icon' })\n    });\n\n    marker._origLatLng = latlng;\n    marker._index = index;\n\n    marker.on('drag', this._onMarkerDrag, this);\n    marker.on('dragend', this._onMarkerDragEnd, this);\n    marker.on('contextmenu', this._removeMarker, this);\n\n    this._markerGroup.addLayer(marker);\n\n    return marker;\n  },\n\n  _createMiddleMarker: function _createMiddleMarker(leftM, rightM) {\n    var _this2 = this;\n\n    var latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n    var middleMarker = this._createMarker(latlng);\n    var icon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n    middleMarker.setIcon(icon);\n\n    // save reference to this middle markers on the neighboor regular markers\n    leftM._middleMarkerNext = middleMarker;\n    rightM._middleMarkerPrev = middleMarker;\n\n    middleMarker.on('click', function () {\n\n      // TODO: move the next two lines inside _addMarker() as soon as\n      // https://github.com/Leaflet/Leaflet/issues/4484\n      // is fixed\n      var icon = L.divIcon({ className: 'marker-icon' });\n      middleMarker.setIcon(icon);\n\n      _this2._addMarker(middleMarker, leftM, rightM);\n    });\n    middleMarker.on('movestart', function () {\n\n      // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n      // https://github.com/Leaflet/Leaflet/issues/4484\n      middleMarker.on('moveend', function () {\n        var icon = L.divIcon({ className: 'marker-icon' });\n        middleMarker.setIcon(icon);\n\n        middleMarker.off('moveend');\n      });\n\n      _this2._addMarker(middleMarker, leftM, rightM);\n    });\n  },\n\n  _addMarker: function _addMarker(newM, leftM, rightM) {\n    // first, make this middlemarker a regular marker\n    newM.off('movestart');\n    newM.off('click');\n\n    // now, create the polygon coordinate point for that marker\n    var latlng = newM.getLatLng();\n    var coords = this._line._latlngs;\n    var index = leftM._index + 1;\n\n    coords.splice(index, 0, latlng);\n\n    // associate polygon coordinate with marker coordinate\n    newM._origLatLng = coords[index];\n\n    // push into marker array & update the indexes for every marker\n    this._markers.splice(index, 0, newM);\n    this._markers.map(function (marker, i) {\n      return marker._index = i;\n    });\n\n    // create the new middlemarkers\n    this._createMiddleMarker(leftM, newM);\n    this._createMiddleMarker(newM, rightM);\n\n    // fire edit event\n    this._fireEdit();\n\n    if (this.options.snappable) {\n      this._initSnappableMarkers();\n    }\n  },\n\n  _removeMarker: function _removeMarker(e) {\n    var marker = e.target;\n    var coords = this._line._latlngs;\n    var index = marker._index;\n\n    // only continue if this is NOT a middle marker (those can't be deleted)\n    if (index === undefined) {\n      return;\n    }\n\n    // remove polygon coordinate from this marker\n    coords.splice(index, 1);\n\n    // if the poly has no coordinates left, remove the layer\n    // else, redraw it\n    if (coords.length < 1) {\n      this._line.remove();\n    } else {\n      this._line.redraw();\n    }\n\n    // remove the marker and the middlemarkers next to it from the map\n    if (marker._middleMarkerPrev) {\n      this._markerGroup.removeLayer(marker._middleMarkerPrev);\n    }\n    if (marker._middleMarkerNext) {\n      this._markerGroup.removeLayer(marker._middleMarkerNext);\n    }\n    this._markerGroup.removeLayer(marker);\n\n    // find neighbor marker-indexes\n    var leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n    var rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n    // don't create middlemarkers if there is only one marker left\n    if (rightMarkerIndex !== leftMarkerIndex) {\n      var leftM = this._markers[leftMarkerIndex];\n      var rightM = this._markers[rightMarkerIndex];\n      this._createMiddleMarker(leftM, rightM);\n    }\n\n    // remove the marker from the markers array & update indexes\n    this._markers.splice(index, 1);\n    this._markers.map(function (marker, i) {\n      return marker._index = i;\n    });\n\n    // fire edit event\n    this._fireEdit();\n  },\n\n  _onMarkerDrag: function _onMarkerDrag(e) {\n    // dragged marker\n    var marker = e.target;\n\n    // the dragged markers neighbors\n    var nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n    var prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n    // update marker coordinates which will update polygon coordinates\n    L.extend(marker._origLatLng, marker._latlng);\n    this._line.redraw();\n\n    // update middle markers on the left and right\n    // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n    var markerLatLng = marker.getLatLng();\n    var prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n    var nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n    if (marker._middleMarkerNext) {\n      var middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n      marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n    }\n\n    if (marker._middleMarkerPrev) {\n      var middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n      marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n    }\n  },\n\n  _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n    this._fireEdit();\n  },\n\n  _fireEdit: function _fireEdit() {\n    this._line.edited = true;\n    this._line.fire('pm:edit');\n  },\n\n  _calcMiddleLatLng: function _calcMiddleLatLng(latlng1, latlng2) {\n    var map = this._line._map,\n        p1 = map.project(latlng1),\n        p2 = map.project(latlng2);\n\n    var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n    return latlng;\n  }\n});\n'use strict';\n\nL.PM.Edit.Poly = L.PM.Edit.extend({\n    initialize: function initialize(poly) {\n        this._poly = poly;\n        this._enabled = false;\n    },\n\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable: function enable() {\n        var _this = this;\n\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\n        this.options = options;\n\n        if (!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._poly.on('remove', function (e) {\n            _this.disable(e.target);\n        });\n\n        // preventOverlap needs the turf library. If it's not included, deactivate it again\n        // if(window.turf === undefined && this.options.preventOverlap) {\n        //     console.warn('TurfJS not found, preventOverlap is deactivated');\n        //     this.options.preventOverlap = false;\n        // }\n\n        if (this.options.draggable) {\n            this._initDraggableLayer();\n        }\n\n        // if(this.options.preventOverlap) {\n        //\n        //     // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        //     this._poly.on('pm:drag', this._handleOverlap, this);\n        //\n        //     // set new coordinates, more details inside the function\n        //     this._poly.on('pm:dragend', this._applyPossibleCoordsChanges, this);\n        // }\n    },\n\n    enabled: function enabled() {\n        return this._enabled;\n    },\n\n    disable: function disable() {\n        var poly = arguments.length <= 0 || arguments[0] === undefined ? this._poly : arguments[0];\n\n\n        // if it's not enabled, it doesn't need to be disabled\n        if (!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if polygon is being dragged\n        if (poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        var el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n    },\n\n    _initMarkers: function _initMarkers() {\n        var map = this._poly._map;\n\n        // cleanup old ones first\n        if (this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        var coords = this._poly._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for (var k = 0; k < coords.length; k++) {\n\n            var nextIndex = k + 1 >= coords.length ? 0 : k + 1;\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    // creates initial markers for coordinates\n    _createMarker: function _createMarker(latlng, index) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function _createMiddleMarker(leftM, rightM) {\n        var _this2 = this;\n\n        var latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        var middleMarker = this._createMarker(latlng);\n        var icon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n        middleMarker.setIcon(icon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', function () {\n\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({ className: 'marker-icon' });\n            middleMarker.setIcon(icon);\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', function () {\n\n            // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function () {\n                var icon = L.divIcon({ className: 'marker-icon' });\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._poly._latlngs[0];\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map(function (marker, i) {\n            return marker._index = i;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        var coords = this._poly._latlngs[0];\n        var index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if (coords.length < 1) {\n            this._poly.remove();\n        } else {\n            this._poly.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        var leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        var rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        if (rightMarkerIndex !== leftMarkerIndex) {\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map(function (marker, i) {\n            return marker._index = i;\n        });\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _onMarkerDrag: function _onMarkerDrag(e) {\n\n        // dragged marker\n        var marker = e.target;\n\n        // the dragged markers neighbors\n        var nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        var prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._poly.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        var markerLatLng = marker.getLatLng();\n        var prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        var nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        var middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n        marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n\n        var middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n        marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        // }\n    },\n\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n\n        // if(this.options.preventOverlap) {\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _fireEdit: function _fireEdit() {\n        // fire edit event\n        this._poly.edited = true;\n        this._poly.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng: function _calcMiddleLatLng(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._poly._map,\n            p1 = map.project(latlng1),\n            p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n\n});\n'use strict';\n\nL.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    // TODO: clean up variable names like _button should be _options and that domNodeVariable stuff\n    initialize: function initialize(options) {\n        this._button = {};\n        this._button = this.setButton(options);\n    },\n\n    onAdd: function onAdd(map) {\n\n        this._map = map;\n\n        this._container = this._map.pm.Toolbar.container;\n        this.buttonsDomNode = this._makeButton(this._button);\n        this._container.appendChild(this.buttonsDomNode);\n\n        return this._container;\n    },\n\n    onRemove: function onRemove(map) {},\n\n    setButton: function setButton(options) {\n        var button = {\n            'className': options.className,\n            'iconUrl': options.iconUrl,\n            'onClick': options.onClick,\n            'afterClick': options.afterClick,\n            'doToggle': options.doToggle,\n            'toggleStatus': options.toggleStatus,\n            'disableOtherButtons': options.disableOtherButtons\n        };\n\n        return button;\n    },\n\n    getText: function getText() {\n        return this._button.text;\n    },\n\n    getIconUrl: function getIconUrl() {\n        return this._button.iconUrl;\n    },\n\n    destroy: function destroy() {\n        this._button = {};\n        this._update();\n    },\n\n    toggle: function toggle(e) {\n        if (typeof e === 'boolean') {\n            this._button.toggleStatus = e;\n        } else {\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n        this._applyStyleClasses();\n\n        return this._button.toggleStatus;\n    },\n    toggled: function toggled() {\n        return this._button.toggleStatus;\n    },\n    onCreate: function onCreate() {\n        this.toggle(false);\n    },\n    _triggerClick: function _triggerClick(e) {\n        this._button.onClick(e);\n        this._clicked(e);\n        this._button.afterClick(e);\n    },\n    _makeButton: function _makeButton(button) {\n        var _this = this;\n\n        var newButton = L.DomUtil.create('a', 'leaflet-buttons-control-button', this._container);\n        if (button.toggleStatus) {\n            L.DomUtil.addClass(newButton, 'active');\n        }\n\n        var image = L.DomUtil.create('div', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n        // before the actual click, trigger a click on currently toggled buttons to\n        // untoggle them and their functionality\n        L.DomEvent.addListener(newButton, 'click', function (e) {\n            if (_this._button.disableOtherButtons) {\n                _this._map.pm.Toolbar.triggerClickOnToggledButtons(_this);\n            }\n        });\n        L.DomEvent.addListener(newButton, 'click', this._triggerClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n    },\n\n    _applyStyleClasses: function _applyStyleClasses() {\n\n        if (!this._container) {\n            return;\n        }\n\n        if (!this._button.toggleStatus) {\n            L.DomUtil.removeClass(this.buttonsDomNode, 'active');\n        } else {\n            L.DomUtil.addClass(this.buttonsDomNode, 'active');\n        }\n    },\n\n    _clicked: function _clicked() {\n\n        if (this._button.doToggle) {\n            this.toggle();\n        }\n        return;\n    }\n\n});\n'use strict';\n\n/**\n* The Icons used in this Toolbar are CC-BY Glyphicons - http://glyphicons.com/\n*/\n\nL.PM.Toolbar = L.Class.extend({\n    options: {\n        drawLine: false,\n        drawPolygon: false,\n        editPolygon: false,\n        dragPolygon: false,\n        deleteLayer: false\n    },\n    initialize: function initialize(map) {\n        this.map = map;\n\n        this.buttons = {};\n        this.container = L.DomUtil.create('div', 'leaflet-pm-toolbar leaflet-bar leaflet-control');\n        this._defineButtons();\n    },\n\n    getButtons: function getButtons() {\n        return this.buttons;\n    },\n\n    addControls: function addControls() {\n        var options = arguments.length <= 0 || arguments[0] === undefined ? this.options : arguments[0];\n\n        // adds all buttons to the map specified inside options\n\n        // first set the options\n        L.Util.setOptions(this, options);\n\n        // now show the specified buttons\n        this._showHideButtons();\n    },\n    _addButton: function _addButton(name, button) {\n        this.buttons[name] = button;\n        this.options[name] = this.options[name] || false;\n\n        return this.buttons[name];\n    },\n    triggerClickOnToggledButtons: function triggerClickOnToggledButtons(exceptThisButton) {\n        // this function is used when - e.g. drawing mode is enabled and a possible\n        // other active mode (like removal tool) is already active.\n        // we can't have two active modes because of possible event conflicts\n        // so, we trigger a click on all currently active (toggled) buttons\n        for (var name in this.buttons) {\n            if (this.buttons[name] !== exceptThisButton && this.buttons[name].toggled()) {\n                this.buttons[name]._triggerClick();\n            }\n        }\n    },\n    toggleButton: function toggleButton(name, status) {\n        // does not fire the events/functionality of the button\n        // this just changes the state and is used if a functionality (like Draw)\n        // is enabled manually via script\n\n        // as some mode got enabled, we still have to trigger the click on the other buttons\n        // to disable their mode\n        this.triggerClickOnToggledButtons(this.buttons[name]);\n\n        // now toggle the state of the button\n        return this.buttons[name].toggle(status);\n    },\n    _defineButtons: function _defineButtons() {\n        var _this = this;\n\n        // some buttons are still in their respective classes, like L.PM.Draw.Poly\n        var deleteButton = {\n            'className': 'icon-delete',\n            'onClick': function onClick(e) {},\n            'afterClick': function afterClick(e) {\n                _this.map.pm.toggleRemoval(_this.buttons.deleteLayer.toggled());\n            },\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        var drawLineButton = {\n            'className': 'icon-line',\n            'onClick': function onClick(e) {},\n            'afterClick': function afterClick(e) {\n                // toggle drawing mode\n                _this.map.pm.Draw.Line.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        var drawPolyButton = {\n            'className': 'icon-polygon',\n            'onClick': function onClick(e) {},\n            'afterClick': function afterClick(e) {\n                // toggle drawing mode\n                _this.map.pm.Draw.Poly.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        var editButton = {\n            'className': 'icon-edit',\n            'onClick': function onClick(e) {},\n            'afterClick': function afterClick(e) {\n                _this.map.pm.toggleGlobalEditMode({\n                    snappable: true,\n                    draggable: true\n                });\n            },\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        var dragButton = {\n            'className': 'icon-drag',\n            'onClick': function onClick(e) {},\n            'afterClick': function afterClick(e) {},\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        this._addButton('drawLine', new L.Control.PMButton(drawLineButton));\n        this._addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        this._addButton('editPolygon', new L.Control.PMButton(editButton));\n        this._addButton('dragPolygon', new L.Control.PMButton(dragButton));\n        this._addButton('deleteLayer', new L.Control.PMButton(deleteButton));\n    },\n    _showHideButtons: function _showHideButtons() {\n        // loop through all buttons\n        var buttons = this.getButtons();\n\n        for (var btn in buttons) {\n            if (this.options[btn]) {\n                // if options say the button should be visible, add it to the map\n                buttons[btn].addTo(this.map);\n            } else {\n                // if not, remove it\n                buttons[btn].remove();\n            }\n        }\n    }\n});","var DragMixin = {\n    _initDraggableLayer: function() {\n        // temporary coord variable for delta calculation\n        this._tempDragCoord;\n\n        let PMObj = this._poly || this._line;\n      \n        // add CSS class\n        var el = PMObj._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n\n        var onMouseUp = (e) => {\n\n            // re-enable map drag\n            PMObj._map.dragging.enable();\n\n            // clear up mousemove event\n            PMObj._map.off('mousemove');\n\n            // clear up mouseup event\n            PMObj.off('mouseup');\n\n            // show markers again\n            this._initMarkers();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(() => {\n                // set state\n                this._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n                // fire pm:dragend event\n                PMObj.fire('pm:dragend');\n\n                // fire edit\n                this._fireEdit();\n            }, 10);\n\n        };\n\n\n        var onMouseMove = (e) => {\n\n            if(!this._dragging) {\n\n                // set state\n                this._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                PMObj.bringToFront();\n\n                // disbale map drag\n                PMObj._map.dragging.disable();\n\n                // hide markers\n                this._markerGroup.clearLayers();\n\n                // fire pm:dragstart event\n                PMObj.fire('pm:dragstart');\n\n\n            }\n\n            this._onLayerDrag(e);\n\n        };\n\n        PMObj.on('mousedown', (e) => {\n\n            // save for delta calculation\n            this._tempDragCoord = e.latlng;\n\n            PMObj.on('mouseup', onMouseUp);\n\n            // listen to mousemove on map (instead of polygon),\n            // otherwise fast mouse movements stop the drag\n            PMObj._map.on('mousemove', onMouseMove);\n\n        });\n    },\n    dragging: function() {\n        return this._dragging;\n    },\n\n    _onLayerDrag: function(e) {\n        let PMObj = this._poly || this._line;\n        // latLng of mouse event\n        let latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        let deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng\n        };\n\n        // create the new coordinates array\n        let coords = PMObj._latlngs[0];\n        let newLatLngs = coords.map((currentLatLng) => {\n            return {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            }\n        });\n\n        // set new coordinates and redraw\n        PMObj.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // fire pm:dragstart event\n        PMObj.fire('pm:drag');\n    },\n};\n","// this isn't included anymore but if you want to re-enable it:\n// 1. include this mixing inside L.PM.Edit.js\n// 2. include the turf.js dependency in your project before leaflet.pm\n// 3. uncomment all code inside L.PM.Edit.Poly that has an if-check on options.preventOverlap\n// 4. pass the option preventOverlap to the enable() function on your layer\nvar OverlapMixin = {\n\n    _applyPossibleCoordsChanges: function() {\n\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if(this._tempPolygon) {\n\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n\n    },\n\n    _drawTemporaryPolygon: function(geoJson) {\n\n        // hide our polygon\n        this._poly.setStyle({opacity: 0, fillOpacity: 0});\n\n        // draw a temporary polygon (happens during drag & intersection)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n\n    },\n\n    _handleOverlap: function() {\n\n        let mainPoly = this._poly;\n        let layers = this._layerGroup.getLayers();\n        let changed = false;\n        let resultingGeoJson = this._poly.toGeoJSON();\n\n        layers\n        .filter(layer => !Object.is(layer, mainPoly))\n        .map((layer) => {\n\n            let intersect;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch(e) {\n                console.warn('Turf Error.');\n            }\n\n            if(intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if(resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n\n        });\n\n        if(this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if(changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({opacity: 1, fillOpacity: 0.2});\n        }\n\n\n\n    }\n}\n","var SnapMixin = {\n    _initSnappableMarkers: function() {\n        let PMObj = this._poly || this._line;\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        this._markers.forEach((marker) => {\n\n            marker.off('drag', this._handleSnapping, this);\n            marker.on('drag', this._handleSnapping, this);\n\n            marker.off('dragend', this._cleanupSnapping, this);\n            marker.on('dragend', this._cleanupSnapping, this);\n        });\n\n\n        PMObj.off('pm:dragstart', this._unsnap, this);\n        PMObj.on('pm:dragstart', this._unsnap, this);\n\n    },\n    _unsnap: function(e) {\n        // delete the last snap\n        delete this._snapLatLng;\n    },\n    _cleanupSnapping: function(e) {\n\n        // delete it, we need to refresh this with each start of a drag because\n        // meanwhile, new layers could've been added to the map\n        delete this._snapList;\n\n        this.debugIndicatorLines.forEach((line) => {\n            line.remove();\n        });\n    },\n    _handleSnapping: function(e) {\n        let PMObj = this._poly || this._line;\n      \n        // create a list of polygons that the marker could snap to\n        // this isn't inside a movestart/dragstart callback because middlemarkers are initialized\n        // after dragstart/movestart so it wouldn't fire for them\n        if(this._snapList === undefined) {\n            this._createSnapList(e);\n        }\n\n        // if there are no layers to snap to, stop here\n        if(this._snapList.length <= 0) {\n            return false;\n        }\n\n        let marker = e.target;\n\n        // get the closest layer, it's closest latlng, segment and the distance\n        let closestLayer = this._calcClosestLayer(marker.getLatLng(), this._snapList);\n\n        // find the final latlng that we want to snap to\n        let snapLatLng = this._checkPrioritiySnapping(closestLayer);\n\n        // minimal distance before marker snaps (in pixels)\n        let minDistance = this.options.snapDistance;\n\n        // event info for pm:snap and pm:unsnap\n        let eventInfo = {\n            marker,\n            snapLatLng,\n            segment: closestLayer.segment,\n            layer: PMObj,\n            layerInteractedWith: closestLayer.layer // for lack of a better property name\n        };\n\n        if(closestLayer.distance < minDistance) {\n\n            // snap the marker\n            marker.setLatLng(snapLatLng);\n            this._onMarkerDrag(e);\n\n            // check if the snapping position differs from the last snap\n            if(this._snapLatLng !== snapLatLng) {\n\n                // if yes, save it and fire the pm:snap event\n                this._snapLatLng = snapLatLng;\n                marker.fire('pm:snap', eventInfo);\n                PMObj.fire('pm:snap', eventInfo);\n            }\n\n        } else {\n            // no more snapping\n\n            // if it was previously snapped...\n            if(this._snapLatLng) {\n\n                // ...unsnap\n                this._unsnap(eventInfo);\n\n                // and fire unsnap event\n                eventInfo.marker.fire('pm:unsnap', eventInfo);\n                PMObj.fire('pm:unsnap', eventInfo);\n            }\n        }\n    },\n\n    // we got the point we want to snap to (C), but we need to check if a coord of the polygon\n    // receives priority over C as the snapping point. Let's check this here\n    _checkPrioritiySnapping: function(closestLayer) {\n        let PMObj = this._poly || this._line;\n        let map = PMObj._map;\n\n        // A and B are the points of the closest segment to P (the marker position we want to snap)\n        let A = closestLayer.segment[0];\n        let B = closestLayer.segment[1];\n\n        // C is the point we would snap to on the segment.\n        // The closest point on the closest segment of the closest polygon to P. That's right.\n        let C = closestLayer.latlng;\n\n        // distances from A to C and B to C to check which one is closer to C\n        let distanceAC = this._getDistance(map, A, C);\n        let distanceBC = this._getDistance(map, B, C);\n\n        // closest latlng of A and B to C\n        let closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n        // distance between closestVertexLatLng and C\n        let shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n        // the distance that needs to be undercut to trigger priority\n        let priorityDistance = this.options.snapDistance;\n\n        // the latlng we ultemately want to snap to\n        let snapLatlng;\n\n        // if C is closer to the closestVertexLatLng (A or B) than the snapDistance,\n        // the closestVertexLatLng has priority over C as the snapping point.\n        if(shortestDistance < priorityDistance) {\n            snapLatlng = closestVertexLatLng;\n        } else {\n            snapLatlng = closestLayer.latlng;\n        }\n\n        // return the snapping point\n        return snapLatlng;\n\n    },\n    _createSnapList: function() {\n        let PMObj = this._poly || this._line;\n        let layers = [];\n        let debugIndicatorLines = [];\n\n        // find all layers that are or inherit from Polylines...\n        PMObj._map.eachLayer((layer) => {\n            if(layer instanceof L.Polyline) {\n                layers.push(layer);\n\n                // this is for debugging\n                let debugLine = L.polyline([], {color: 'red'});\n                debugIndicatorLines.push(debugLine);\n\n                // uncomment 👇 this in to show debugging lines\n                // debugLine.addTo(this._poly._map);\n            }\n        });\n\n        // ...except myself\n        layers = layers.filter((layer) => PMObj !== layer);\n\n        this._snapList = layers;\n        this.debugIndicatorLines = debugIndicatorLines;\n    },\n    _calcClosestLayer: function(latlng, layers) {\n        let PMObj = this._poly || this._line;\n        let map = PMObj._map;\n\n        // the closest polygon to our dragged marker latlng\n        let closestLayer = {};\n\n        // loop through the layers\n        layers.forEach((layer, index) => {\n\n            // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n            let results = this._calcLayerDistances(latlng, layer);\n\n            // show indicator lines, it's for debugging\n            this.debugIndicatorLines[index].setLatLngs([latlng, results.latlng]);\n\n            // save the info if it doesn't exist or if the distance is smaller than the previous one\n            if(closestLayer.distance === undefined || results.distance < closestLayer.distance) {\n                closestLayer = results;\n                closestLayer.layer = layer;\n            }\n\n        });\n\n        // return the closest layer and it's data\n        // if there is no closest layer, return undefined\n        return closestLayer;\n\n\n    },\n    _calcLayerDistances: function(latlng, layer) {\n        let PMObj = this._poly || this._line;\n        let map = PMObj._map;\n\n        // the point P which we want to snap (probpably the marker that is dragged)\n        let P = latlng;\n\n        // the coords of the layer\n        let coords = this._poly ? layer.getLatLngs()[0] : layer.getLatLngs();\n\n        // the closest segment (line between two points) of the layer\n        let closestSegment;\n\n        // the shortest distance from P to closestSegment\n        let shortestDistance;\n\n        // loop through the coords of the layer\n        coords.forEach((coord, index) => {\n            // take this coord (A)...\n            let A = coord;\n\n            // and the next coord (B) as points\n            let nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            let B = coords[nextIndex];\n\n            // calc the distance between P and AB-segment\n            let distance = this._getDistanceToSegment(map, P, A, B);\n\n            // is the distance shorter than the previous one? Save it and the segment\n            if(shortestDistance === undefined || distance < shortestDistance) {\n                shortestDistance = distance;\n                closestSegment = [A, B];\n            }\n\n        });\n\n        // now, take the closest segment (closestSegment) and calc the closest point to P on it.\n        let C = this._getClosestPointOnSegment(map, latlng, closestSegment[0], closestSegment[1]);\n\n        // return the latlng of that sucker\n        return {\n            latlng: C,\n            segment: closestSegment,\n            distance: shortestDistance\n        };\n\n    },\n    _getClosestPointOnSegment: function(map, latlng, latlngA, latlngB) {\n        let maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity) {\n            maxzoom = map.getZoom();\n        }\n        let P = map.project(latlng, maxzoom);\n        let A = map.project(latlngA, maxzoom);\n        let B = map.project(latlngB, maxzoom);\n        let closest = L.LineUtil.closestPointOnSegment(P, A, B);\n        return map.unproject(closest, maxzoom);\n    },\n    _getDistanceToSegment: function (map, latlng, latlngA, latlngB) {\n        let P = map.latLngToLayerPoint(latlng);\n        let A = map.latLngToLayerPoint(latlngA);\n        let B = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(P, A, B);\n    },\n    _getDistance: function (map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    }\n};\n","/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize: function() {\n\n        var initLayerGroup = function() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        };\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n\n        var initPolygon = function() {\n            this.pm = new L.PM.Edit.Poly(this);\n        };\n        L.Polygon.addInitHook(initPolygon);\n\n        var initLine = function() {\n          this.pm = new L.PM.Edit.Line(this);\n        };\n        L.Polyline.addInitHook(initLine);\n\n        var initMap = function() {\n            this.pm = new L.PM.Map(this);\n        };\n        L.Map.addInitHook(initMap);\n\n    }\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n","L.PM.Map = L.Class.extend({\n    initialize(map) {\n        this.map = map;\n        this.Draw = new L.PM.Draw(map);\n        this.Toolbar = new L.PM.Toolbar(map);\n    },\n    addControls: function(options) {\n        this.Toolbar.addControls(options);\n    },\n    enableDraw: function(shape = 'Poly') {\n        this.Draw.enable(shape);\n    },\n    disableDraw: function(shape = 'Poly') {\n        this.Draw.disable(shape);\n    },\n    removeLayer: function(e) {\n\n        var layer = e.target;\n        if(!layer._layers && !layer.pm.dragging()) {\n            e.target.remove();\n        }\n    },\n    toggleRemoval: function(enabled) {\n        if(enabled) {\n            this.map.eachLayer((layer) => {\n                layer.on('click', this.removeLayer);\n            });\n        } else {\n            this.map.eachLayer((layer) => {\n                layer.off('click', this.removeLayer);\n            });\n        }\n\n\n\n    },\n    globalEditEnabled: function() {\n        return this._globalEditMode;\n    },\n    toggleGlobalEditMode: function(options) {\n\n        // find all layers that are or inherit from Polylines...\n        let layers = [];\n        this.map.eachLayer((layer) => {\n            if(layer instanceof L.Polyline) {\n                layers.push(layer);\n            }\n        });\n\n        if(this.globalEditEnabled()) {\n            // disable\n\n            this._globalEditMode = false;\n\n            layers.forEach(function(layer, index) {\n                layer.pm.disable();\n            });\n\n        } else {\n            // enable\n\n            this._globalEditMode = true;\n\n            layers.forEach(function(layer, index) {\n                layer.pm.enable(options);\n            });\n\n\n        }\n\n    },\n});\n","L.PM.Draw = L.Class.extend({\n\n    initialize: function(map) {\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly','Line'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape] = new L.PM.Draw[shape](this._map);\n        });\n\n    },\n    getShapes: function() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enable: function(shape) {\n\n        if(!shape) {\n            throw 'Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(',');\n        }\n\n        // disable drawing for all shapes\n        this.disable();\n\n        // enable draw for a shape\n        this[shape].enable();\n\n    },\n    disable: function() {\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach((shape) => {\n            this[shape].disable();\n        });\n\n    },\n    addControls: function() {\n        // add control buttons for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape].addButton();\n        });\n    }\n});\n","L.PM.Edit = L.Class.extend({\n    includes: [DragMixin, SnapMixin]\n});\n","L.PM.Draw.Line = L.PM.Draw.extend({\n\n    initialize: function(map) {\n        this._map = map;\n        this._shape = 'Line';\n        this.registerButton();\n        this.toolbarButtonName = 'drawLine';\n    },\n    enable: function(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], {color: 'red'});\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createLinePoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', {shape: this._shape});\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n    },\n    disable: function() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if(!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createLinePoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', {shape: this._shape});\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n    },\n    enabled: function() {\n        return this._enabled;\n    },\n    toggle: function(options) {\n        if(this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    registerButton: function(map) {\n        var drawLineButton = {\n            'className': 'icon-line',\n            'onClick': function() {\n\n            },\n            'afterClick': function(e) {\n                self.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false\n        };\n    },\n    _syncHintLine: function(e) {\n\n        var linePoints = this._polyline.getLatLngs();\n\n        if(linePoints.length > 0) {\n            var lastLinePoint = linePoints[linePoints.length - 1];\n            this._hintline.setLatLngs([lastLinePoint, e.latlng]);\n        }\n\n    },\n    _createLinePoint: function(e) {\n\n        // is this the first point?\n        var last = this._polyline.getLatLngs().length === 0 ? false : true;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, last);\n\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n\n    },\n    _createMarker: function(latlng, last) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({className: 'marker-icon'})\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if(last) {\n            marker.on('click', this._finishLine, this);\n        }\n\n        return marker;\n\n    },\n    _finishLine: function() {\n\n        var coords = this._polyline.getLatLngs();\n        var lineLayer = L.polyline(coords).addTo(this._map);\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: lineLayer\n        });\n    },\n});\n","L.PM.Draw.Poly = L.PM.Draw.extend({\n\n    initialize: function(map) {\n        this._map = map;\n        this._shape = 'Poly';\n        this.registerButton();\n        this.toolbarButtonName = 'drawPolygon';\n    },\n    enable: function(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], {color: 'red'});\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', {shape: this._shape});\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n    },\n    disable: function() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if(!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', {shape: this._shape});\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n    },\n    enabled: function() {\n        return this._enabled;\n    },\n    toggle: function(options) {\n\n        if(this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n\n    },\n    registerButton: function(map) {\n\n        var drawPolyButton = {\n            'className': 'icon-polygon',\n            'onClick': function() {\n\n            },\n            'afterClick': function(e) {\n                self.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false\n        };\n\n\n        // this._drawButton = L.PM.Toolbar.addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        //\n        // this._map.on('pm:drawstart', (e) => {\n        //     if(e.shape === this._shape && !this._drawButton.toggled()) {\n        //         this._drawButton._clicked();\n        //     }\n        // });\n        //\n        // this._map.on('pm:drawend', (e) => {\n        //     if(e.shape === this._shape && this._drawButton.toggled()) {\n        //         this._drawButton._clicked();\n        //     }\n        // });\n\n\n\n    },\n    _syncHintLine: function(e) {\n\n        var polyPoints = this._polyline.getLatLngs();\n\n        if(polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n\n\n\n    },\n    _createPolygonPoint: function(e) {\n\n        // is this the first point?\n        var first = this._polyline.getLatLngs().length === 0 ? true : false;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n\n    },\n    _finishPolygon: function() {\n\n        var coords = this._polyline.getLatLngs();\n        var polygonLayer = L.polygon(coords).addTo(this._map);\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n    },\n    _createMarker: function(latlng, first) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({className: 'marker-icon'})\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if(first) {\n            marker.on('click', this._finishPolygon, this);\n        }\n\n        return marker;\n\n    },\n});\n","// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function(layerGroup) {\n\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        let availableEvents = ['pm:edit', 'pm:dragstart', 'pm:drag', 'pm:dragend', 'pm:snap', 'pm:unsnap', 'pm:raiseMarkers'];\n\n        this._layers.forEach((layer) => {\n\n            // listen to the events of the layers in this group\n            availableEvents.forEach((event) => {\n                layer.on(event, this._fireEvent, this);\n            });\n\n            // add reference for the group to each layer inside said group\n            layer.pm._layerGroup = this._layerGroup;\n        });\n\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', (e) => {\n\n            this.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if(e.target.pm.enabled()) {\n                this.enable(this.getOptions());\n            }\n        });\n    },\n    _fireEvent: function(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit: function(options) {\n        this._options = options;\n        this._layers.forEach(layer => {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable: function(options) {\n        this._options = options;\n        this._layers.forEach(layer => {\n            layer.pm.enable(options);\n        });\n    },\n    disable: function() {\n        this._layers.forEach(layer => {\n            layer.pm.disable();\n        });\n    },\n    enabled: function() {\n        let enabled = this._layers.find((layer) => layer.pm.enabled());\n        return !!enabled;\n    },\n    dragging: function() {\n        let dragging = this._layers.find((layer) => layer.pm.dragging());\n        return !!dragging;\n    },\n    getOptions: function() {\n        return this._options;\n    }\n});\n","L.PM.Edit.Line = L.PM.Edit.extend({\n    initialize: function(line) {\n        this._line = line;\n        this._enabled = false;\n    },\n  \n    toggleEdit: function(options) {\n        if(!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n  \n    enable: function(options = {}) {\n      this.options = options;\n\n      if(!this.enabled()) {\n        // if it was already enabled, disable first\n        // we don't block enabling again because new options might be passed\n        this.disable();\n      }\n\n      this._enabled = true;\n\n      // init markers\n      this._initMarkers();\n\n      // if polygon gets removed from map, disable edit mode\n      this._line.on('remove', (e) => {\n        this.disable(e.target);\n      });\n\n      if(this.options.draggable) {\n        this._initDraggableLayer();\n      }\n    },\n  \n    enabled: function() {\n        return this._enabled;\n    },\n  \n    disable: function(line = this._line) {\n      if(!this.enabled()) {\n        return false;\n      }\n\n      // prevent disabling if polygon is being dragged\n      if(line.pm._dragging) {\n        return false;\n      }\n      line.pm._enabled = false;\n      line.pm._markerGroup.clearLayers();\n\n      // clean up draggable\n      line.off('mousedown');\n      line.off('mouseup');\n\n      // remove draggable class\n      var el = line._path;\n      L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n    },\n  \n    _initMarkers: function() {\n      let map = this._line._map;\n\n      // cleanup old ones first\n      if(this._markerGroup) {\n        this._markerGroup.clearLayers();\n      }\n\n      // add markerGroup to map, markerGroup includes regular and middle markers\n      this._markerGroup = new L.LayerGroup();\n      map.addLayer(this._markerGroup);\n\n      // create marker for each coordinate\n      let coords = this._line._latlngs;\n\n      // the marker array, it includes only the markers that're associated with the coordinates\n      this._markers = coords.map(this._createMarker, this);\n\n      // create small markers in the middle of the regular markers\n      for(var k = 0; k < coords.length-1; k++) {\n\n        var nextIndex = k+1;\n        this._createMiddleMarker(\n          this._markers[k], this._markers[nextIndex]\n        );\n      }\n      \n      if(this.options.snappable) {\n        this._initSnappableMarkers();\n      }\n    },\n  \n    _createMarker: function(latlng, index) {\n      let marker = new L.Marker(latlng, {\n        draggable: true,\n        icon: L.divIcon({className: 'marker-icon'})\n      });\n\n      marker._origLatLng = latlng;\n      marker._index = index;\n\n      marker.on('drag', this._onMarkerDrag, this);\n      marker.on('dragend', this._onMarkerDragEnd, this);\n      marker.on('contextmenu', this._removeMarker, this);\n\n      this._markerGroup.addLayer(marker);\n\n      return marker;\n    },\n  \n    _createMiddleMarker: function(leftM, rightM) {\n      let latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n      let middleMarker = this._createMarker(latlng);\n      let icon = L.divIcon({className: 'marker-icon marker-icon-middle'})\n      middleMarker.setIcon(icon);\n\n      // save reference to this middle markers on the neighboor regular markers\n      leftM._middleMarkerNext = middleMarker;\n      rightM._middleMarkerPrev = middleMarker;\n\n      middleMarker.on('click', () => {\n\n        // TODO: move the next two lines inside _addMarker() as soon as\n        // https://github.com/Leaflet/Leaflet/issues/4484\n        // is fixed\n        var icon = L.divIcon({className: 'marker-icon'});\n        middleMarker.setIcon(icon);\n\n        this._addMarker(middleMarker, leftM, rightM);\n      });\n      middleMarker.on('movestart', () => {\n\n        // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n        // https://github.com/Leaflet/Leaflet/issues/4484\n        middleMarker.on('moveend', function() {\n          var icon = L.divIcon({className: 'marker-icon'});\n          middleMarker.setIcon(icon);\n\n          middleMarker.off('moveend');\n        });\n\n        this._addMarker(middleMarker, leftM, rightM);\n      });\n    },\n  \n    _addMarker: function(newM, leftM, rightM) {\n      // first, make this middlemarker a regular marker\n      newM.off('movestart');\n      newM.off('click');\n\n      // now, create the polygon coordinate point for that marker\n      let latlng = newM.getLatLng();\n      let coords = this._line._latlngs;\n      let index = leftM._index + 1;\n\n      coords.splice(index, 0, latlng);\n\n      // associate polygon coordinate with marker coordinate\n      newM._origLatLng = coords[index];\n\n      // push into marker array & update the indexes for every marker\n      this._markers.splice(index, 0, newM);\n      this._markers.map((marker, i) => marker._index = i);\n\n      // create the new middlemarkers\n      this._createMiddleMarker(leftM, newM);\n      this._createMiddleMarker(newM, rightM);\n\n      // fire edit event\n      this._fireEdit();\n\n      if(this.options.snappable) {\n        this._initSnappableMarkers();\n      }\n    },\n  \n    _removeMarker: function(e) {\n      let marker = e.target;\n      let coords = this._line._latlngs;\n      let index = marker._index;\n\n      // only continue if this is NOT a middle marker (those can't be deleted)\n      if(index === undefined) {\n        return;\n      }\n\n      // remove polygon coordinate from this marker\n      coords.splice(index, 1);\n\n      // if the poly has no coordinates left, remove the layer\n      // else, redraw it\n      if(coords.length < 1) {\n        this._line.remove();\n      } else {\n        this._line.redraw();\n      }\n\n      // remove the marker and the middlemarkers next to it from the map\n      if(marker._middleMarkerPrev) { \n        this._markerGroup.removeLayer(marker._middleMarkerPrev); \n      }\n      if(marker._middleMarkerNext) { \n        this._markerGroup.removeLayer(marker._middleMarkerNext); \n      }\n      this._markerGroup.removeLayer(marker);\n\n      // find neighbor marker-indexes\n      let leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n      let rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n      // don't create middlemarkers if there is only one marker left\n      if(rightMarkerIndex !== leftMarkerIndex) {\n        let leftM = this._markers[leftMarkerIndex];\n        let rightM = this._markers[rightMarkerIndex];\n        this._createMiddleMarker(leftM, rightM);\n      }\n\n      // remove the marker from the markers array & update indexes\n      this._markers.splice(index, 1);\n      this._markers.map((marker, i) => marker._index = i);\n\n      // fire edit event\n      this._fireEdit();\n    },\n  \n    _onMarkerDrag: function(e) {\n      // dragged marker\n      let marker = e.target;\n\n      // the dragged markers neighbors\n      let nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n      let prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n      // update marker coordinates which will update polygon coordinates\n      L.extend(marker._origLatLng, marker._latlng);\n      this._line.redraw();\n\n      // update middle markers on the left and right\n      // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n      let markerLatLng = marker.getLatLng();\n      let prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n      let nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n      if(marker._middleMarkerNext) {\n        let middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n        marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n      }\n      \n      if(marker._middleMarkerPrev) {\n        let middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n        marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n      }\n\n    },\n  \n    _onMarkerDragEnd: function(e) {\n      this._fireEdit();\n    },\n  \n    _fireEdit: function () {\n      this._line.edited = true;\n      this._line.fire('pm:edit');\n    },\n  \n    _calcMiddleLatLng: function(latlng1, latlng2) {\n      var map = this._line._map,\n        p1 = map.project(latlng1),\n        p2 = map.project(latlng2);\n\n      var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n      return latlng;\n    },\n});\n","L.PM.Edit.Poly = L.PM.Edit.extend({\n    initialize: function(poly) {\n        this._poly = poly;\n        this._enabled = false;\n    },\n\n    toggleEdit: function(options) {\n        if(!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable: function(options = {}) {\n\n        this.options = options;\n\n        if(!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._poly.on('remove', (e) => {\n            this.disable(e.target);\n        });\n\n\n        // preventOverlap needs the turf library. If it's not included, deactivate it again\n        // if(window.turf === undefined && this.options.preventOverlap) {\n        //     console.warn('TurfJS not found, preventOverlap is deactivated');\n        //     this.options.preventOverlap = false;\n        // }\n\n        if(this.options.draggable) {\n            this._initDraggableLayer();\n        }\n\n        // if(this.options.preventOverlap) {\n        //\n        //     // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        //     this._poly.on('pm:drag', this._handleOverlap, this);\n        //\n        //     // set new coordinates, more details inside the function\n        //     this._poly.on('pm:dragend', this._applyPossibleCoordsChanges, this);\n        // }\n    },\n\n    enabled: function() {\n        return this._enabled;\n    },\n\n    disable: function(poly = this._poly) {\n\n        // if it's not enabled, it doesn't need to be disabled\n        if(!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if polygon is being dragged\n        if(poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        var el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n    },\n\n    _initMarkers: function() {\n        let map = this._poly._map;\n\n        // cleanup old ones first\n        if(this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        let coords = this._poly._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for(var k = 0; k < coords.length; k++) {\n\n            var nextIndex = k+1 >= coords.length ? 0 : k+1;\n            this._createMiddleMarker(\n                this._markers[k], this._markers[nextIndex]\n            );\n        }\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n\n    },\n\n    // creates initial markers for coordinates\n    _createMarker: function(latlng, index) {\n\n        let marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({className: 'marker-icon'})\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function(leftM, rightM) {\n\n        let latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        let middleMarker = this._createMarker(latlng);\n        let icon = L.divIcon({className: 'marker-icon marker-icon-middle'})\n        middleMarker.setIcon(icon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', () => {\n\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({className: 'marker-icon'});\n            middleMarker.setIcon(icon);\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', () => {\n\n            // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function() {\n                var icon = L.divIcon({className: 'marker-icon'});\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n\n\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker: function(newM, leftM, rightM) {\n\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        let latlng = newM.getLatLng();\n        let coords = this._poly._latlngs[0];\n        let index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map((marker, i) => marker._index = i);\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n\n    },\n\n    _removeMarker: function(e) {\n        let marker = e.target;\n        let coords = this._poly._latlngs[0];\n        let index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if(index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if(coords.length < 1) {\n            this._poly.remove();\n        } else {\n            this._poly.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        let leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        let rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        if(rightMarkerIndex !== leftMarkerIndex) {\n            let leftM = this._markers[leftMarkerIndex];\n            let rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map((marker, i) => marker._index = i);\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n\n\n    },\n\n\n\n    _onMarkerDrag: function(e) {\n\n        // dragged marker\n        let marker = e.target;\n\n        // the dragged markers neighbors\n        let nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        let prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._poly.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        let markerLatLng = marker.getLatLng();\n        let prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        let nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        let middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n        marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n\n        let middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n        marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        // }\n\n    },\n\n    _onMarkerDragEnd: function(e) {\n\n        // if(this.options.preventOverlap) {\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n\n    },\n\n    _fireEdit: function () {\n        // fire edit event\n        this._poly.edited = true;\n        this._poly.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng: function(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._poly._map,\n            p1 = map.project(latlng1),\n            p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n\n});\n","L.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    // TODO: clean up variable names like _button should be _options and that domNodeVariable stuff\n    initialize: function (options) {\n        this._button = {};\n        this._button = this.setButton(options);\n    },\n\n    onAdd: function (map) {\n\n        this._map = map;\n\n        this._container = this._map.pm.Toolbar.container;\n        this.buttonsDomNode = this._makeButton(this._button);\n        this._container.appendChild(this.buttonsDomNode);\n\n        return this._container;\n    },\n\n    onRemove: function (map) {\n    },\n\n    setButton: function (options) {\n        var button = {\n            'className': options.className,\n            'iconUrl': options.iconUrl,\n            'onClick': options.onClick,\n            'afterClick': options.afterClick,\n            'doToggle': options.doToggle,\n            'toggleStatus': options.toggleStatus,\n            'disableOtherButtons': options.disableOtherButtons\n        };\n\n        return button;\n    },\n\n    getText: function () {\n        return this._button.text;\n    },\n\n    getIconUrl: function () {\n        return this._button.iconUrl;\n    },\n\n    destroy: function () {\n        this._button = {};\n        this._update();\n    },\n\n    toggle: function (e) {\n        if(typeof e === 'boolean'){\n            this._button.toggleStatus = e;\n        }\n        else{\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n        this._applyStyleClasses();\n\n        return this._button.toggleStatus;\n    },\n    toggled: function () {\n        return this._button.toggleStatus;\n    },\n    onCreate: function() {\n        this.toggle(false);\n    },\n    _triggerClick: function(e) {\n        this._button.onClick(e);\n        this._clicked(e);\n        this._button.afterClick(e);\n    },\n    _makeButton: function(button) {\n\n        var newButton = L.DomUtil.create('a', 'leaflet-buttons-control-button', this._container);\n        if(button.toggleStatus) {\n            L.DomUtil.addClass(newButton,'active');\n        }\n\n        var image = L.DomUtil.create('div', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n        // before the actual click, trigger a click on currently toggled buttons to\n        // untoggle them and their functionality\n        L.DomEvent.addListener(newButton, 'click', (e) => {\n            if(this._button.disableOtherButtons) {\n                this._map.pm.Toolbar.triggerClickOnToggledButtons(this);\n            }\n        });\n        L.DomEvent.addListener(newButton, 'click', this._triggerClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n\n    },\n\n    _applyStyleClasses: function() {\n\n        if(!this._container) {\n            return;\n        }\n\n        if(!this._button.toggleStatus) {\n            L.DomUtil.removeClass(this.buttonsDomNode,'active');\n        } else {\n            L.DomUtil.addClass(this.buttonsDomNode,'active');\n        }\n    },\n\n    _clicked: function () {\n\n        if(this._button.doToggle){\n            this.toggle();\n        }\n        return;\n    }\n\n});\n","/**\n* The Icons used in this Toolbar are CC-BY Glyphicons - http://glyphicons.com/\n*/\n\nL.PM.Toolbar = L.Class.extend({\n    options: {\n        drawLine: false,\n        drawPolygon: false,\n        editPolygon: false,\n        dragPolygon: false,\n        deleteLayer: false,\n    },\n    initialize(map) {\n        this.map = map;\n\n        this.buttons = {};\n        this.container = L.DomUtil.create('div', 'leaflet-pm-toolbar leaflet-bar leaflet-control');\n        this._defineButtons();\n    },\n    getButtons: function() {\n        return this.buttons;\n    },\n\n    addControls: function(options = this.options) {\n        // adds all buttons to the map specified inside options\n\n        // first set the options\n        L.Util.setOptions(this, options)\n\n        // now show the specified buttons\n        this._showHideButtons();\n    },\n    _addButton: function(name, button) {\n        this.buttons[name] = button;\n        this.options[name] = this.options[name] || false;\n\n        return this.buttons[name];\n    },\n    triggerClickOnToggledButtons: function(exceptThisButton) {\n        // this function is used when - e.g. drawing mode is enabled and a possible\n        // other active mode (like removal tool) is already active.\n        // we can't have two active modes because of possible event conflicts\n        // so, we trigger a click on all currently active (toggled) buttons\n        for (var name in this.buttons) {\n            if(this.buttons[name] !== exceptThisButton && this.buttons[name].toggled()) {\n                this.buttons[name]._triggerClick();\n            }\n        }\n    },\n    toggleButton: function(name, status) {\n        // does not fire the events/functionality of the button\n        // this just changes the state and is used if a functionality (like Draw)\n        // is enabled manually via script\n\n        // as some mode got enabled, we still have to trigger the click on the other buttons\n        // to disable their mode\n        this.triggerClickOnToggledButtons(this.buttons[name]);\n\n        // now toggle the state of the button\n        return this.buttons[name].toggle(status);\n\n\n    },\n    _defineButtons: function() {\n\n        // some buttons are still in their respective classes, like L.PM.Draw.Poly\n        var deleteButton = {\n            'className': 'icon-delete',\n            'onClick': (e) => {\n\n            },\n            'afterClick': (e) => {\n                this.map.pm.toggleRemoval(this.buttons.deleteLayer.toggled());\n            },\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        var drawLineButton = {\n             'className': 'icon-line',\n             'onClick': (e) => {\n\n             },\n             'afterClick': (e) => {\n                 // toggle drawing mode\n                 this.map.pm.Draw.Line.toggle();\n             },\n             'doToggle': true,\n             'toggleStatus': false,\n             'disableOtherButtons': true\n        };\n\n        var drawPolyButton = {\n             'className': 'icon-polygon',\n             'onClick': (e) => {\n\n             },\n             'afterClick': (e) => {\n                 // toggle drawing mode\n                 this.map.pm.Draw.Poly.toggle();\n             },\n             'doToggle': true,\n             'toggleStatus': false,\n             'disableOtherButtons': true\n        };\n\n        var editButton = {\n             'className': 'icon-edit',\n             'onClick': (e) => {\n             },\n             'afterClick': (e) => {\n                 this.map.pm.toggleGlobalEditMode({\n                     snappable: true,\n                     draggable: true\n                 });\n             },\n             'doToggle': true,\n             'toggleStatus': false,\n             'disableOtherButtons': true\n        };\n\n        var dragButton = {\n             'className': 'icon-drag',\n             'onClick': (e) => {\n             },\n             'afterClick': (e) => {\n\n             },\n             'doToggle': true,\n             'toggleStatus': false,\n             'disableOtherButtons': true\n        };\n\n        this._addButton('drawLine', new L.Control.PMButton(drawLineButton));\n        this._addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        this._addButton('editPolygon', new L.Control.PMButton(editButton));\n        this._addButton('dragPolygon', new L.Control.PMButton(dragButton));\n        this._addButton('deleteLayer', new L.Control.PMButton(deleteButton));\n\n    },\n    _showHideButtons: function() {\n        // loop through all buttons\n        var buttons = this.getButtons();\n\n        for (var btn in buttons) {\n            if(this.options[btn]) {\n                // if options say the button should be visible, add it to the map\n                buttons[btn].addTo(this.map);\n            } else {\n                // if not, remove it\n                buttons[btn].remove();\n            }\n        }\n    }\n});\n"],"sourceRoot":"/source/"}